## 题目
* [题目链接](https://adworld.xctf.org.cn/media/task/attachments/9244cc370caa43f491636f8c4670fe7d.zip)
* 其公钥文件解析后可以知道
```
e = 3
n = 23292710978670380403641273270002884747060006568046290011918413375473934024039715180540887338067
```
* ```n```挺小，用```yahu```分解，得到
```
p = 26440615366395242196516853423447
q = 27038194053540661979045656526063
h = 32581479300404876772405716877547
```
用```d = gmpy2.invert(e,(p-1)*(q-1)*(h-1))```报错，找不到逆元,这说明```gcd(e,phi(n))!=1```
```
print(gmpy2.gcd(e, p-1))
print(gmpy2.gcd(e, q-1))
print(gmpy2.gcd(e, h-1))
# output
# 3
# 1
# 3
```
原来```e```就是它们的最大公约数。这没有办法继续求下去了，但```e```这么小，可以开立方根爆破吗，尝试后发现也不大行
* 如果把```n```拆解```p```和```q```和```r```，那么上述等式可以拆为三个等式
```
x^3 ≡ c mod p
x^3 ≡ c mod q
x^3 ≡ c mod h
c ≡ 20827907988103030784078915883129 mod p
c ≡ 19342563376936634263836075415482 mod q
c ≡ 10525283947807760227880406671000 mod h
```
* 这里是三次剩余，要求出```x```不能先用中国剩余定理，还需要先逐个解方程，具体解起来有些困难，参考别人的[教程](https://github.com/p4-team/ctf/tree/master/2016-03-12-0ctf/rsa)发现
[wolframalpha](https://www.wolframalpha.com/input/?i=x%5E3+%3D+19342563376936634263836075415482+%28mod+19342563376936634263836075415482%29)有这个功能
其实这个平台挺强大的，还可以画很多图，求很多数学方程。
类似于二次剩余，求出来的解可能不止一个，将其组合，用中国剩余定理求出```x```
* ```python```脚本
```
import gmpy2
from Crypto.Util.number import *
def CRT(c0,c1,c2,n0,n1,n2):
    N = n0*n1*n2
    N0 = N // n0
    N1 = N // n1
    N2 = N // n2
    d0 = gmpy2.invert(N0, n0)
    d1 = gmpy2.invert(N1, n1)
    d2 = gmpy2.invert(N2, n2)
    return (c0*N0*d0 + c1*N1*d1 + c2*N2*d2) % N

e = 3
n = 23292710978670380403641273270002884747060006568046290011918413375473934024039715180540887338067
q = 27038194053540661979045656526063
h = 32581479300404876772405716877547
p = n//(h*q)

roots0 = [5686385026105901867473638678946, 7379361747422713811654086477766, 13374868592866626517389128266735]
roots1 = [19616973567618515464515107624812]
roots2 = [6149264605288583791069539134541, 13028011585706956936052628027629, 13404203109409336045283549715377]

for r0 in roots0:
    for r1 in roots1:
        for r2 in roots2:
            M = CRT(r0, r1, r2, p, q, h)
            print(long_to_bytes(M))
```
* 在最后的输出中可以找到一条
```
b'\x02\xd1^\xcb\x84\x84RC\xf3J\x000ctf{HahA!Thi5_1s_n0T_rSa~}\n'
```
